<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Alexandru Monahov" />

<meta name="date" content="2024-04-23" />

<title>wconf: Weighted Confusion Matrix</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">wconf: Weighted Confusion Matrix</h1>
<h4 class="author">Alexandru Monahov</h4>
<h4 class="date">2024-04-23</h4>



<div id="the-wconf-package" class="section level2">
<h2>The wconf package</h2>
<p><strong>wconf is a package that allows users to create weighted
confusion matrices and accuracy scores</strong></p>
<p>Used to improve the model selection process, the package includes
several weighting schemes which can be parameterized, as well as the
option for custom weight configurations. Furthermore, users can decide
whether they wish to positively or negatively affect the accuracy score
as a result of applying weights to the confusion matrix. “wconf”
integrates with the “caret” package, but it can also work standalone
when provided data in matrix form.</p>
<div id="about-confusion-matrices" class="section level4">
<h4><strong>About confusion matrices</strong></h4>
<p>Confusion matrices are used to visualize the performance of
classification models in tabular format. A confusion matrix takes the
form of an “n x n” matrix depicting:</p>
<ol style="list-style-type: lower-alpha">
<li><p>the reference category, in columns;</p></li>
<li><p>the predicted category, in rows;</p></li>
<li><p>the number of observation corresponding to each combination of
“reference - predicted” category couples, as cells of the
matrix.</p></li>
</ol>
<p>Visually, the simplest binary classification confusion matrix takes
on the form:</p>
<p><span class="math display">\[
A = \begin{bmatrix}TP &amp; FP \\FN &amp; TN\\ \end{bmatrix}
\]</span> where:</p>
<p><span class="math inline">\(TP\)</span> - True Positives - the number
of observations that were “positive” and were correctly predicted as
being “positive”</p>
<p><span class="math inline">\(TN\)</span> - True Negatives - the number
of originally “negative” observations that were correctly predicted by
the model as being “negative”.</p>
<p><span class="math inline">\(FP\)</span> - False Positives - also
called “Type 1 Error” - represents observations that are in fact
“negative”, but were incorrectly classified by the model as being
“positive”.</p>
<p><span class="math inline">\(FN\)</span> - False Negatives - also
called “Type 2 Error” - represents observations that are in fact
“positive”, but were incorrectly classified by the model as being
“negative”.</p>
<p>The traditional accuracy metric is compiled by adding the true
positives and true negatives, and dividing them by the total number of
observations.</p>
<p><span class="math display">\[
A = \frac{TP + TN} {N}
\]</span></p>
<p>A weighted confusion matrix consists in attributing weights to all
classification categories based on their distance from the correctly
predicted category. This is important for multi-category classification
problems (where there are three or more categories), where distance from
the correctly predicted category matters.</p>
<p>The weighted confusion matrix, for the simple binary classification,
takes the form:</p>
<p><span class="math display">\[
A = \begin{bmatrix}w1*TP &amp; w2*FP \\w2*FN &amp; w1*TN\\ \end{bmatrix}
\]</span></p>
<p>In the case of the weighted confusion matrix, a weighted accuracy
score can be calculated by summing up all of the elements of the matrix
and dividing the resulting amount by the number of observations.</p>
<p><span class="math display">\[
A = \frac{w1*TP + w2*FP + w2*FN + w1*TN} {N}
\]</span></p>
</div>
<div id="references" class="section level4">
<h4><strong>References</strong></h4>
<p>For more details on the method, see the paper:</p>
<p>Monahov, A. (2023). wconf: The weighted confusion matrix and accuracy
scores package for R</p>
</div>
</div>
<div id="functions" class="section level2">
<h2>Functions</h2>
<div id="weightmatrix---configure-and-visualize-a-weight-matrix" class="section level4">
<h4><strong>weightmatrix - configure and visualize a weight
matrix</strong></h4>
<p>This function compiles a weight matrix according to one of several
weighting schemas and allows users to visualize the impact of the weight
matrix on each element of the confusion matrix.</p>
<p>In R, simply call the function:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">weightmatrix</span>(n, <span class="at">weight.type =</span> <span class="st">&quot;arithmetic&quot;</span>, <span class="at">weight.penalty =</span> <span class="cn">FALSE</span>, <span class="at">standard.deviation =</span> <span class="dv">2</span>, <span class="at">geometric.multiplier =</span> <span class="dv">2</span>, <span class="at">interval.high=</span><span class="dv">1</span>, <span class="at">interval.low =</span> <span class="sc">-</span><span class="dv">1</span>, <span class="at">custom.weights =</span> <span class="cn">NA</span>, <span class="at">plot.weights =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>The function takes as input:</p>
<p><em>n</em> – the number of classes contained in the confusion
matrix.</p>
<p><em>weight.type</em> – the weighting schema to be used. Can be one
of: “arithmetic” - a decreasing arithmetic progression weighting scheme,
“geometric” - a decreasing geometric progression weighting scheme,
“normal” - weights drawn from the right tail of a normal distribution,
“interval” - weights contained on a user-defined interval, “custom” -
custom weight vector defined by the user.</p>
<p><em>weight.penalty</em> – determines whether the weights associated
with non-diagonal elements generated by the “normal”, “arithmetic” and
“geometric” weight types are positive or negative values. By default,
the value is set to FALSE, which means that generated weights will be
positive values.</p>
<p><em>standard.deviation</em> – standard deviation of the normal
distribution, if the normal distribution weighting schema is used.</p>
<p><em>geometric.multiplier</em> – the multiplier used to construct the
geometric progression series, if the geometric progression weighting
scheme is used.</p>
<p><em>interval.high</em> – the upper bound of the weight interval, if
the interval weighting scheme is used.</p>
<p><em>interval.low</em> – the lower bound of the weight interval, if
the interval weighting scheme is used.</p>
<p><em>custom.weights</em> – the vector of custom weights to be applied,
is the custom weighting scheme was selected. The vector should be equal
to “n”, but can be larger, with excess values being ignored.</p>
<p><em>plot.weights</em> – optional setting to enable plotting of weight
vector, corresponding to the first column of the weight matrix</p>
<p>The function outputs a matrix:</p>
<table>
<tbody>
<tr class="odd">
<td>w</td>
<td>the nxn weight matrix.</td>
</tr>
</tbody>
</table>
</div>
<div id="wconfusionmatrix---compute-a-weighted-confusion-matrix" class="section level4">
<h4><strong>wconfusionmatrix - compute a weighted confusion
matrix</strong></h4>
<p>This function calculates the weighted confusion matrix by
multiplying, element-by-element, a weight matrix with a supplied
confusion matrix object.</p>
<p>In R, simply call the function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">wconfusionmatrix</span>(m, <span class="at">weight.type =</span> <span class="st">&quot;arithmetic&quot;</span>, <span class="at">weight.penalty =</span> <span class="cn">FALSE</span>, <span class="at">standard.deviation =</span> <span class="dv">2</span>, <span class="at">geometric.multiplier =</span> <span class="dv">2</span>, <span class="at">interval.high=</span><span class="dv">1</span>, <span class="at">interval.low =</span> <span class="sc">-</span><span class="dv">1</span>, <span class="at">custom.weights =</span> <span class="cn">NA</span>, <span class="at">print.weighted.accuracy =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>The function takes as input:</p>
<p><em>m</em> – the caret confusion matrix object or simple matrix.</p>
<p><em>weight.type</em> – the weighting schema to be used. Can be one
of: “arithmetic” - a decreasing arithmetic progression weighting scheme,
“geometric” - a decreasing geometric progression weighting scheme,
“normal” - weights drawn from the right tail of a normal distribution,
“interval” - weights contained on a user-defined interval, “custom” -
custom weight vector defined by the user.</p>
<p><em>weight.penalty</em> – determines whether the weights associated
with non-diagonal elements generated by the “normal”, “arithmetic” and
“geometric” weight types are positive or negative values. By default,
the value is set to FALSE, which means that generated weights will be
positive values.</p>
<p><em>standard.deviation</em> – standard deviation of the normal
distribution, if the normal distribution weighting schema is used.</p>
<p><em>geometric.multiplier</em> – the multiplier used to construct the
geometric progression series, if the geometric progression weighting
scheme is used.</p>
<p><em>interval.high</em> – the upper bound of the weight interval, if
the interval weighting scheme is used.</p>
<p><em>interval.low</em> – the lower bound of the weight interval, if
the interval weighting scheme is used.</p>
<p><em>custom.weights</em> – the vector of custom weights to be applied,
is the custom weighting scheme was selected. The vector should be equal
to “n”, but can be larger, with excess values being ignored.</p>
<p><em>print.weighted.accuracy</em> – optional setting to print the
weighted accuracy metric, which represents the sum of all weighted
confusion matrix cells divided by the total number of observations.</p>
<p>The function outputs a matrix:</p>
<table>
<tbody>
<tr class="odd">
<td>w_m</td>
<td>the nxn weighted confusion matrix.</td>
</tr>
</tbody>
</table>
</div>
<div id="balancedaccuracy---calculate-accuracy-scores-for-imbalanced-data" class="section level4">
<h4><strong>balancedaccuracy - calculate accuracy scores for imbalanced
data</strong></h4>
<p>This function calculates classification accuracy scores using the
sine-based formulas proposed by Starovoitov and Golub (2020). The
advantage of the new method consists in producing improved results when
compared with the standard balanced accuracy function, by taking into
account the class distribution of errors. This feature renders the
method useful when confronted with imbalanced data.</p>
<p>In R, simply call the function:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">balancedaccuracy</span>(m, <span class="at">print.scores =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>The function takes as input:</p>
<p><em>m</em> – the caret confusion matrix object or simple matrix.</p>
<p><em>print.scores</em> – used to display the accuracy scores when set
to TRUE.</p>
<p>The function outputs a list of objects:</p>
<table>
<tbody>
<tr class="odd">
<td>ACCmetrics</td>
<td>accuracy metrics.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="examples" class="section level2">
<h2>Examples</h2>
<div id="producing-a-weighted-confusion-matrix-in-conjunction-with-the-caret-package" class="section level4">
<h4><strong>Producing a weighted confusion matrix in conjunction with
the caret package</strong></h4>
<p>This example provides a real-world usage example of the wconf package
on the Iris dataset included in R.</p>
<p>To load the wconf package, run the command:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(wconf)</span></code></pre></div>
<p>We will attempt the more difficult task of predicting petal length
from sepal width. In addition, for this task, we are only given
categorical information about the length of the petals, specifically
that they are:</p>
<ul>
<li><p>“Short (length between: 1-3)”</p></li>
<li><p>“Medium (length between: 3-5 cm)”</p></li>
<li><p>“Long (length between: 5-7 cm)”.</p></li>
</ul>
<p>Numeric data is available for the sepal width.</p>
<p>Using caret, we train a multinomial logistic regression model to fit
the numeric sepal width onto our categorical petal length data. We run
10-fold cross-validation, repeated 3 times to avoid overfitting and find
optimal regression coefficient values for various data
configurations.</p>
<p>Finally, we extract the confusion matrix. We wish to weigh the
confusion matrix to represent preference for observations fitted closer
to the correct value. We would like to assign some degree of positive
value to observations that are incorrectly classified, but are close to
the correct category. Since our categories are equally spaced, we can
use an arithmetic weighing scheme.</p>
<p>Let’s first visualize what this weighting schema would look like:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># View the weight matrix and plot for a 3-category classification problem, using the arithmetic sequence option.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">weightmatrix</span>(<span class="dv">3</span>, <span class="at">weight.type =</span> <span class="st">&quot;arithmetic&quot;</span>, <span class="at">plot.weights =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAYFBMVEUAAAAAADoAAGYAOjoAOpAAZrY6AAA6ADo6AGY6Ojo6OpA6kNtmAABmADpmZgBmtv+QOgCQkGaQ27aQ2/+2ZgC2tma225C2///bkDrb////tmb/trb/25D//7b//9v///8yxFCRAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAH8UlEQVR4nO2dC3eqOBRG0Wk7j9qpd3TmUkbl///LC4larcKXxznkUL+91u3tA5Kw10lI4AhVS0apSjfAOhQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCCAsqJoNpQTJFqcHBQEoCDCxoC9dewaaCkdQ+BhYiuJdzLqh4oKsB1F5QcaDyIIg00FkQpDlIDIiyG4QWRFkNojsCDIaRIYE2QwiJUHbqno+rLsVxXtUcQaDSEdQ/fTROXpu2/3qNa44c4ZUBB3WnZZmsWm9qqjirAWRiqD9qutZzfJne/oaVZwtReYiKLYubZTHIKcqvjhDQWTrLJZanSKm5kFXGxhRZFaQlSDSFlTHn8U+t7GgqOxF+2kqzcJwF3ObFVdkXFD5IFJqqDvFdwyMQDHFFQ4ipYlidZwfNlXSRDGjamn0lhqepKXGzcYFFcUL2r9t3P9Dy9D2uFhtR7eKPORyhtIFDc1wWvkIagsGUayg7edMZmB06alPazCRMSh1DxHSI2iU/cpLHIifpMMtE0Tm50GKbZCt83NDOMcRrfd6r+kVJQjaZpmJrVdov2QSxqChGxU69d7sOLGiFEFDVwlV6hXdVbO284aH9fOU9d7bd0pFCWPQ7kUghPKOcUJDkYJO85tCZ7HP3SdTNKt50FUBEymaraCp+lnKWezcyTLGIomjmySIEiLIL0Cb6j1hRhT/IZrARqmRfpqvnz6GrmVI1guKUVeUPlFslj9HrpmJ1TtZQbnlX0SQ71h9BBkQpB1EOWNQzpxa8qhUDaWc5t15rAuenGW96EFpBtGM50GKxaWUbPyI1ILouwhSC6LoxerreSZdcrF6t0gVRaoRNHJhpOzBaJQZU3nARRGdDqEQRImn+aeP7dg67Hi/cOoI0ig3ZaK42HSz6PGV6n7VL9MKCBIPorSlRr9KBeuM7WJTRJB00WmL1V4QWqnW1WsZQbJBlB5BW3StY/fyWxlBoqUnj0E1vp54WA9vo3yVQi6Ikheri4AcD4l6S1egvdTISSTPY+qruuf7Yll3DYWvSaPKJAqJ2/A4R06/Fh1db+laUrrYMUEoL5Rydo6oJv8GZfKGo9cTBRPJM8mtKE1QAwJINpE8j8wgShBUj2e4tippwDlk1RUraAvttBqJ5HnkBFH8FcWAbY1FUFZ1sRHU9y98N0wjkTyP5CBKunGIHWkkkmeSWGPaWWz3kjtZnF5QYhApzYPk6pUkpdL0mXTecr6IoJQgSluL5ScClxGUUG+0oMzrQNH1ShMbRN/n1rNS1Q8oKC6IHlFQlKLHFKRx3N9MUHAQPayg0CZMLGjSi/aIoEY8cAS1Qa14bEEBQfTggnBDHl4QCiIKAm2hoHY8iCjIMdwcCvIMBhEFnRhokZIgO/fmw7kfRDqCLN2bj+Beo1QE2buzGsidIFIRZO3efAQ3ihhBX6lGfwzebxx79+YjuA4ipbOYwXvzEVQD3wfvJNwGe1wEEQXdp7r5JniPOMolkmdyCqJHviYNqC6+Bm8uXPsMoCAAF6sALlYBxZYas0FDUMBiNb7QAGSL08q0aoMiKKkNiNkIClisJrUBMR9BeLGa1AbEjASVKZSCJi2OgmRLo6BJK9cp9PsJ+k5QEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAggIag3R8C77o74m5VSrwazlNHPzlBQdB+JfEyQM9h3R1PLfDEA0+flNLEGZIX1GQ+1PwK/9jYjBd9XOEekxT5VgxxQU31mvFml4EyhZ4L4SgtqEW3XRMQeYHnibp0F5MXBG5TRpYVWdgMBDViY7TjsI56hpR9QZLx4wuM6mPmBdXSfiJfB2pdUMADwMPxauKaZ1zQ7kU0fvrn0V8k8YRgXFDts0nE5kH9E0fjQpKLVQAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIYESQy/a9TmxqBNM6MrAhyCdJbS9zFC4eNVMUE4KOKU1XyXEUdMHpYTv/92kzPkPl+D7K8+uDu98ufvQR1vjf7N9+VMu/++TFWjSD8QYLgq4yl7fPPlPXRVD/jcuh6hOBmz5NqOnk7VfP3b9OX5+IdFjrRpoFQZfvCd6/bXyX6wX5P3QafB/sxiifHtYsNu5P/Ta73wWTzO9gTVBPU1VekM9H7ez4nLXuR2+q++qHqC7cxp+FlY8FQVddrBt1lv8dI6g5PpDtvb4W1P3NC+rEbaWTYL9gQdA5CroBxhk4dbFzRvNQBO3f/nnT7WE2BF2c5p2KpjqNQe+XG9RXY9C72+NP5R5mQ5CfKLrPhvng6X50A5P74Ek/f7xzFnPu5NPMv2JDkH96nAsG95lA5+Q0D1oeZ0fLf310+XmQF6R9DjMjKIg7+de7v5R72EwEuTHo62ygp9buYTMR5E/4N1Pm3Yv2ED0bQeWgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQYBfZdSMKBYIGXcAAAAASUVORK5CYII=" /><!-- --></p>
<pre><code>#&gt;      [,1] [,2] [,3]
#&gt; [1,]  1.0  0.5  0.0
#&gt; [2,]  0.5  1.0  0.5
#&gt; [3,]  0.0  0.5  1.0</code></pre>
<p>To obtain the weighted confusion matrix, we run the
“wconfusionmatrix” command and provide it the confusion matrix object
generated by caret, a weighting scheme and, optionally, parameterize it
to suit our objectives. Using the “wconfusionmatrix” function will
automatically determine the dimensions of the weighing matrix and the
user need only specify the parameters associated with their weighting
scheme of choice.</p>
<p>The following block of code produces the weighted confusion matrix,
to out specifications.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load libraries and perform transformations</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(caret)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Warning: package &#39;caret&#39; was built under R version 4.2.3</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Loading required package: ggplot2</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Warning: package &#39;ggplot2&#39; was built under R version 4.2.3</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Loading required package: lattice</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Warning: package &#39;lattice&#39; was built under R version 4.2.3</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(iris)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>iris<span class="sc">$</span>Petal.Length.Cat <span class="ot">=</span> <span class="fu">cut</span>(iris<span class="sc">$</span>Petal.Length, <span class="at">breaks=</span><span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>), <span class="at">right =</span> <span class="cn">FALSE</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Train multinomial logistic regression model using caret</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>control <span class="ot">&lt;-</span> <span class="fu">trainControl</span>(<span class="at">method=</span><span class="st">&quot;repeatedcv&quot;</span>, <span class="at">number=</span><span class="dv">10</span>, <span class="at">repeats=</span><span class="dv">3</span>)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">train</span>(Petal.Length.Cat <span class="sc">~</span> Sepal.Width, <span class="at">data=</span>iris, <span class="at">method=</span><span class="st">&quot;multinom&quot;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">trControl=</span>control)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract original data, predicted values and place them in a table</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> iris<span class="sc">$</span>Petal.Length.Cat</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>yhat <span class="ot">=</span> <span class="fu">predict</span>(model)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>preds <span class="ot">=</span> <span class="fu">table</span>(<span class="at">data=</span>yhat, <span class="at">reference=</span>y)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Construct the confusion matrix</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>confmat <span class="ot">=</span> <span class="fu">confusionMatrix</span>(preds)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the weighted confusion matrix and display the weighted accuracy score</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="fu">wconfusionmatrix</span>(confmat, <span class="at">weight.type =</span> <span class="st">&quot;arithmetic&quot;</span>, <span class="at">print.weighted.accuracy =</span> <span class="cn">TRUE</span>)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Weighted accuracy =  0.7233333 </span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       [1,3) [3,5) [5,7)</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,3)    38   2.5     0</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,5)     1  37.0     9</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [5,7)     0   6.0    15</span></span></code></pre></div>
</div>
<div id="generating-accuracy-metrics-for-imbalanced-data" class="section level4">
<h4><strong>Generating accuracy metrics for imbalanced
data</strong></h4>
<p>Let us now undertake an analysis of the classification performance of
a model on imbalanced data. To do so, we will make use of the
“balancedaccuracy” function.</p>
<p>Consider the following example of loans classified into different
categories of Loan-To-Value (LTV) - an indicator which tells a bank if a
loan has enough collateral to cover against the clients’ default. Lower
values of the indicator denote safer loans.</p>
<p>A bank’s risk department has come up with a model that classifies
loans into one of four categories, depending on the LTV band of the
loan. The results are presented below:</p>
<p>The classification categories can be interpreted in the following
manner:<br />
cat. 1 - loans with LTVs between 40% and 60%<br />
cat. 2 - loans with LTVs between 60% and 80%<br />
cat. 3 - loans with LTVs between 80% and 100%<br />
cat. 4 - loans with LTVs between 100% and 120%</p>
<p>Let’s look at the correlation matrix to get an idea of how well the
model performs.</p>
<p>For category 1 (safest loans with an LTV ratio of 40%-60%), the model
predicts all 50 loans that were issued correctly.</p>
<p>For category 2 loans, only 1 loan out of 107 loans that were issued
with an LTV ratio of 60%-80%, was correctly predicted.</p>
<p>The performance of category 3 is also bad, as the smallest share of
loans issued within this bucket were predicted correctly.</p>
<p>For category 4 loans (highest risk, with LTVs above 100%), Only 4 out
of 37 of the loans belonging to this class were predicted correctly.</p>
<p>Overall, our conclusion is that this is a very bad model at
predicting 3 out of 4 loan categories (categories 2 - 4). We therefore
would want to assign a low score.</p>
<p>Let’s calculate the accuracy metrics of this loan using the
“balancedaccuracy” function.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">balancedaccuracy</span>(mtx)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Confusion matrix: </span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]   50    0  118    5</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    0    1   45   27</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]    0   84   22    1</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [4,]    0   22   57    4</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  Class accuracy metrics: </span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; SinAcc - Starovoitov-Golub Sine-Accuracy Metrics for Imbalanced Classification Data </span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]       [,4]</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 6.63064e-05 0.01237203 0.01043053</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; BalAcc - Balanced Accuracy Function </span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]      [,4]</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 0.009345794 0.09090909 0.1081081</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ACC - Standard Accuracy Function </span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.1766055</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  Overall accuracy metrics: </span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; SinACC = 0.2557172    BalACC = 0.3020907    ACC = 0.1766055 </span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $SinACC</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.2557172</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $SinACC_class</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]       [,4]</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 6.63064e-05 0.01237203 0.01043053</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $BalACC</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.3020907</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $BalACC_class</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]      [,4]</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 0.009345794 0.09090909 0.1081081</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $ACC</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.1766055</span></span></code></pre></div>
<p>Let’s analyze the scores:</p>
<p>SinACC - is the Starovoitov-Golub Sine-Accuracy Function BalACC - is
the Balanced Accuracy Function ACC - is the standard Accuracy
Function</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>SinACC <span class="ot">=</span> <span class="fl">0.2557172</span>    BalACC <span class="ot">=</span> <span class="fl">0.3020907</span>    ACC <span class="ot">=</span> <span class="fl">0.1766055</span></span></code></pre></div>
<p>For the SinACC and BalACC functions, we can also extract the
per-category accuracy metrics, which show us how well each category was
predicted.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Class accuracy metrics<span class="sc">:</span> </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>SinAcc </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>]        [,<span class="dv">2</span>]       [,<span class="dv">3</span>]       [,<span class="dv">4</span>]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="fl">6.63064e-05</span> <span class="fl">0.01237203</span> <span class="fl">0.01043053</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>BalAcc </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>]        [,<span class="dv">2</span>]       [,<span class="dv">3</span>]      [,<span class="dv">4</span>]</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="fl">0.009345794</span> <span class="fl">0.09090909</span> <span class="fl">0.1081081</span></span></code></pre></div>
<p>We notice that, as all observations belonging to the first category
were correctly predicted as being in the first category, both the SinACC
and BalACC functions give it a score of 1 (or 100% correctly
predicted).</p>
<p>For the other categories, SinACC penalizes the number of incorrect
predictions more than BalACC. As a consequence, SinAcc and BalACC
per-category scores will only be close to each other when the number of
correctly predicted cases significantly exceeds that of the incorrectly
predicted cases.</p>
<p>To exemplify this, consider the following case where, for the last
class, the number of correctly predicted observations has been set to
equal more than double the number of incorrectly predicted observations.
As such mtx[4,4] = 70.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>mtx <span class="ot">=</span> <span class="fu">t</span>(<span class="fu">matrix</span>(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">0</span>, <span class="dv">118</span>, <span class="dv">5</span>,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">45</span>, <span class="dv">27</span>,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">84</span>, <span class="dv">22</span>, <span class="dv">1</span>,</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">22</span>, <span class="dv">57</span>, <span class="dv">70</span>),</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">nrow =</span> <span class="dv">4</span>))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="fu">balancedaccuracy</span>(mtx)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Confusion matrix: </span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]   50    0  118    5</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    0    1   45   27</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]    0   84   22    1</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [4,]    0   22   57   70</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  Class accuracy metrics: </span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; SinAcc - Starovoitov-Golub Sine-Accuracy Metrics for Imbalanced Classification Data </span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]      [,4]</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 6.63064e-05 0.01237203 0.6346096</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; BalAcc - Balanced Accuracy Function </span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]      [,4]</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 0.009345794 0.09090909 0.6796117</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ACC - Standard Accuracy Function </span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.2848606</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  Overall accuracy metrics: </span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; SinACC = 0.411762    BalACC = 0.4449666    ACC = 0.2848606 </span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $SinACC</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.411762</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $SinACC_class</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]      [,4]</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 6.63064e-05 0.01237203 0.6346096</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $BalACC</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.4449666</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $BalACC_class</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]      [,4]</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 0.009345794 0.09090909 0.6796117</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $ACC</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.2848606</span></span></code></pre></div>
<p>In this case:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>SinACC <span class="ot">=</span> <span class="fl">0.411762</span>    BalACC <span class="ot">=</span> <span class="fl">0.4449666</span>    ACC <span class="ot">=</span> <span class="fl">0.2848606</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>SinAcc </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>]        [,<span class="dv">2</span>]       [,<span class="dv">3</span>]      [,<span class="dv">4</span>]</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="fl">6.63064e-05</span> <span class="fl">0.01237203</span> <span class="fl">0.6346096</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>BalAcc </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>]        [,<span class="dv">2</span>]       [,<span class="dv">3</span>]      [,<span class="dv">4</span>]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="fl">0.009345794</span> <span class="fl">0.09090909</span> <span class="fl">0.6796117</span></span></code></pre></div>
<p>The accuracy metrics for the 4th category for SinACC and BalACC are
relatively close to each other:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>SinACC[,<span class="dv">4</span>] <span class="ot">=</span> <span class="fl">0.6346096</span>    BalACC[,<span class="dv">4</span>] <span class="ot">=</span> <span class="fl">0.6796117</span></span></code></pre></div>
<p>Notice, however, that both the SinACC and BalACC scores are invariant
to the distance of the predicted value from the correct category. If
there is value in assigning some positive weight to predictions
classified in the vicinity of the correct category or, conversely,
applying a supplementary penalty to predictions situated far away from
the correct category, then you should consider first applying weights to
the confusion matrix using the function “wconfusionmatrix”, and then
using the “balancedaccuracy” function on the weighted matrix.</p>
<p>Finally, let’s consider the case when there is a disproportionately
large number of observations classified correctly in one if the
categories. We assume the following confusion matrix, in which mtx[1,1]
was changed to 5000:</p>
<p>When running the accuracy metrics, we obtain the following
results.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">balancedaccuracy</span>(mtx)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Confusion matrix: </span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] 5000    0  118    5</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    0    1   45   27</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]    0   84   22    1</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [4,]    0   22   57    4</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  Class accuracy metrics: </span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; SinAcc - Starovoitov-Golub Sine-Accuracy Metrics for Imbalanced Classification Data </span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]       [,4]</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 6.63064e-05 0.01237203 0.01043053</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; BalAcc - Balanced Accuracy Function </span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]      [,4]</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 0.009345794 0.09090909 0.1081081</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ACC - Standard Accuracy Function </span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.9333457</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  Overall accuracy metrics: </span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; SinACC = 0.2557172    BalACC = 0.3020907    ACC = 0.9333457 </span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $SinACC</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.2557172</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $SinACC_class</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]       [,4]</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 6.63064e-05 0.01237203 0.01043053</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $BalACC</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.3020907</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $BalACC_class</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1]        [,2]       [,3]      [,4]</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1 0.009345794 0.09090909 0.1081081</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $ACC</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.9333457</span></span></code></pre></div>
<p>The standard accuracy score receives a tremendous improvement, given
that it only considers the total number of correctly classified
observations. Both the SinACC and BalACC scores are unaffected however.
This is because, just as in the initial case, the first category
continues to be estimated correctly in 100% of the predictions that the
model generates for loans in this category.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>SinACC <span class="ot">=</span> <span class="fl">0.2557172</span>    BalACC <span class="ot">=</span> <span class="fl">0.3020907</span>    ACC <span class="ot">=</span> <span class="fl">0.9333457</span></span></code></pre></div>
<p>The SinACC score, remains more conservative than the BalACC, but the
difference between the two continues to be the same.</p>
</div>
</div>
<div id="about-the-author" class="section level2">
<h2>About the author</h2>
<p>The wconf: Weighted Confusion Matrix package was programmed by Dr.
Alexandru Monahov.</p>
<p>Alexandru Monahov holds a PhD in Economics from the University Cote
d’Azur (Nice, France) and a Professional Certificate in Advanced Risk
Management from the New York Institute of Finance (New York, United
States). His Master’s Degree in International Economics and Finance and
his Bachelor’s Degree in Economics and Business Administration were
completed at the University of Nice (Nice, France).</p>
<p>His professional activity includes working for the Bank of England as
a Research Economist and as Expert Consultant at the National Bank of
Moldova, within the Financial Stability Division. Alexandru also
provides training for professionals in finance from Central Banks and
Ministries of Finance at the Center of Excellence in Finance (Ljubljana,
Slovenia) and the Centre for Central Banking Studies (London, UK).
Previously, he worked as assistant and, subsequently, associate
professor at the University of Nice and IAE in France, where he taught
Finance, Economics, Econometrics and Business Administration. He
developed training and professional education curricula for the Chambers
of Commerce and Industry and directed several continuing education
programs.</p>
<p>Dr. Monahov was awarded funding for continuing professional education
by the World Bank through the Reserve Advisory &amp; Management
Partnership Program, a PhD scholarship by the Doctoral School of Nice
and a scholarship of the French Government.</p>
<p>⠀</p>
<pre><code>Copyright Alexandru Monahov, 2023.

You may use, modify and redistribute this code, provided that you give credit to the author and make any derivative work available to the public for free.</code></pre>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
