#' Weight matrix
#'
#' This function compiles a weight matrix according to one of several weighting
#' schemas and allows users to visualize the impact of the weight matrix on each
#' element of the confusion matrix.
#'
#' @param n the number of classes contained in the confusion matrix.
#'
#' @param weight.type the weighting schema to be used. Can be one of:
#' "arithmetic" - a decreasing arithmetic progression weighting scheme,
#' "geometric" - a decreasing geometric progression weighting scheme,
#' "normal" - weights drawn from the right tail of a normal distribution,
#' "interval" - weights contained on a user-defined interval,
#' "sin" - a weighing scheme based on a sine function,
#' "tanh" - a weighing scheme based on a hyperbolic tangent function,
#' "custom" - custom weight vector defined by the user.
#'
#' @param weight.penalty determines whether the weights associated with
#' non-diagonal elements generated by the "normal", "arithmetic" and "geometric"
#' weight types are positive or negative values. By default, the value is set to
#' FALSE, which means that generated weights will be positive values.
#'
#' @param standard.deviation standard deviation of the normal distribution, if
#' the normal distribution weighting schema is used.
#'
#' @param geometric.multiplier the multiplier used to construct the geometric
#' progression series, if the geometric progression weighting scheme is used.
#'
#' @param sin.high the upper segment of the sine function to be used in the
#' weighting scheme.
#'
#' @param sin.low the lower segment of the sine function to be used in the
#' weighting scheme.
#'
#' @param tanh.decay the decay factor of the hyperbolic tangent weighing
#' function. Higher values increase the rate of decay and place less weight on
#' observations farther away from the correctly predicted category.
#'
#' @param interval.high the upper bound of the weight interval, if the interval
#' weighting scheme is used.
#'
#' @param interval.low the lower bound of the weight interval, if the interval
#' weighting scheme is used.
#'
#' @param custom.weights the vector of custom weights to be applied, is the
#' custom weighting scheme was selected. The vector should be equal to "n", but
#' can be larger, with excess values being ignored.
#'
#' @param plot.weights optional setting to enable plotting of weight vector,
#' corresponding to the first column of the weight matrix
#'
#' @return an nxn matrix, containing the weights to be multiplied with the
#'   confusion matrix.
#'
#' @details The number of categories "n" should be greater or equal to 2.
#'
#' @usage weightmatrix(n, weight.type = "arithmetic", weight.penalty = FALSE,
#'                     standard.deviation = 2,
#'                     geometric.multiplier = 2,
#'                     interval.high = 1, interval.low = -1,
#'                     sin.high = 1.5 * pi, sin.low = 0.5 * pi,
#'                     tanh.decay = 3,
#'                     custom.weights = NA,
#'                     plot.weights = FALSE)
#'
#' @keywords weight matrix normal arithmetic geometric progression interval
#'
#' @seealso [wconfusionmatrix()]
#'
#' @author Alexandru Monahov, <https://www.alexandrumonahov.eu.org/>
#'
#' @examples
#' weightmatrix(n=4, weight.type="arithmetic", plot.weights = TRUE)
#' weightmatrix(n=4, weight.type="normal", standard.deviation = 1,
#'              plot.weights = TRUE)
#' weightmatrix(n=4, weight.type="interval", interval.high = 1,
#'              interval.low = -0.5, plot.weights = TRUE)
#' weightmatrix(n=4, weight.type="geometric", geometric.multiplier = 0.6)
#' weightmatrix(n=10, weight.type="sin", sin.low = 0, sin.high = pi,
#'              plot.weights = TRUE)
#' weightmatrix(n=10, weight.type="tanh", tanh.decay = 5, plot.weights = TRUE)
#' weightmatrix(n=4, weight.type="custom", custom.weights = c(1,0.2,0.1,0),
#'              plot.weights = TRUE)
#'
#' @export

weightmatrix <- function(n, weight.type = "arithmetic", weight.penalty = FALSE, standard.deviation = 2, geometric.multiplier = 2, interval.high = 1, interval.low = -1, sin.high=1.5*pi, sin.low = 0.5*pi, tanh.decay = 3, custom.weights = NA, plot.weights = FALSE) {

  if (weight.type == "normal") {
  # Normal distribution
  a <- seq(from = 1, to = n, by = 1)
  fmean <- seq(from = 1, to = n, by = 1)
  mat <- t(mapply(function(mean,sd) dnorm(a,mean,sd)/max(dnorm(a,mean,sd)), mean=fmean, sd=standard.deviation))
  if (weight.penalty == TRUE) {
    mat = -(1-mat)
    diag(mat) = 1
  }
  if (plot.weights == TRUE) {
    plot(mat[,1], type = "l", xaxt = "n", xlab = "Category", ylab = "Weight")
    axis(1, at = 1:length(mat[,1]))
    if (min(mat)<0) {abline(h=0, lty = "dotted")}
  }
  return(mat)
  }

  else if (weight.type == "arithmetic") {
  # Arithmetic progression
  mat = ((n-1)-abs(outer(seq(0, (n-1), 1), seq(0, (n-1), 1), `-`)))/(n-1)
  if (weight.penalty == TRUE) {
    mat = -(1-mat)
    diag(mat) = 1
  }
  if (plot.weights == TRUE) {
    plot(mat[,1], type = "l", xaxt = "n", xlab = "Category", ylab = "Weight")
    axis(1, at = 1:length(mat[,1]))
    if (min(mat)<0) {abline(h=0, lty = "dotted")}
  }
  return(mat)
  }

  else if (weight.type == "geometric") {
  # Geometric progression
  mult = geometric.multiplier
  mat = (abs(outer(seq(0, (n-1), 1), seq(0, (n-1), 1), `-`)))+1
  x=mult^seq(0,(n-1),by=1)
  x_n = (x-min(x))/(max(x)-min(x))
  if (mult > 1){
    x_dict = 1-x_n
  } else if (mult > 0 && mult < 1) {
    x_dict = x_n
  } else if (mult == 1) {
    x_dict = 1-seq(0, (n-1), 1)/(n-1)
  } else if (mult <= 0) {
    stop("Please enter a multiplier value greater than zero.")
  }
  for (i in 1:n) {
    mat[mat==i] = x_dict[i]
  }
  if (weight.penalty == TRUE) {
    mat = -(1-mat)
    diag(mat) = 1
  }
  if (plot.weights == TRUE) {
    plot(mat[,1], type = "l", xaxt = "n", xlab = "Category", ylab = "Weight")
    axis(1, at = 1:length(mat[,1]))
    if (min(mat)<0) {abline(h=0, lty = "dotted")}
  }
  return(mat)
  }

  else if (weight.type == "interval") {
  # Interval weight
  hi = interval.high
  lo = interval.low
  mat = (abs(outer(seq(0, (n-1), 1), seq(0, (n-1), 1), `-`)))+1
  mat_tmp = mat
  x=seq(hi, lo, length.out = n)
  for (i in 1:n) {
    mat[mat_tmp==i] = x[i]
  }
  if (plot.weights == TRUE) {
    plot(mat[,1], type = "l", xaxt = "n", xlab = "Category", ylab = "Weight")
    axis(1, at = 1:length(mat[,1]))
    if (min(mat)<0) {abline(h=0, lty = "dotted")}
  }
  return(mat)
  }

  else if (weight.type == "sin") {
    sin_hi = sin.high
    sin_lo = sin.low
    mat = (abs(outer(seq(0, (n-1), 1), seq(0, (n-1), 1), `-`)))+1
    mat_tmp = mat
    x = sin(seq(sin_lo, sin_hi, length.out = n))
    for (i in 1:n) {
      mat[mat_tmp==i] = x[i]
    }
    if (plot.weights == TRUE) {
      plot(mat[,1], type = "l", xaxt = "n", xlab = "Category", ylab = "Weight")
      axis(1, at = 1:length(mat[,1]))
      if (min(mat)<0) {abline(h=0, lty = "dotted")}
    }

    cat("\n", "Suggested values of the sin.low and sin.high parameters:", "\n", "\n",
        "sin.low = 0.5*pi; sin.high = 1.5*pi -> yields a sigmoid", "\n",
        "sin.low = 0     ; sin.high = pi     -> yields a parabola", "\n",
        "sin.low = 1.0*pi; sin.high = 1.5*pi -> linear descent with slow attenuation at end", "\n",
        "sin.low = 2.5*pi; sin.high = 3.0*pi -> linear descent with slow attenuation at beginning", "\n", "\n"
        )

    return(mat)
  }

  else if (weight.type == "tanh") {
    tanh_decay = tanh.decay # higher values mean quicker decay (less weight placed on values far away from correct classification)
    mat = (abs(outer(seq(0, (n-1), 1), seq(0, (n-1), 1), `-`)))+1
    mat_tmp = mat
    x = 1-tanh(seq(0, tanh_decay, length.out = n))
    if (weight.penalty == TRUE) {
      x = tanh(seq(0, tanh_decay, length.out = n))
    }
    for (i in 1:n) {
      mat[mat_tmp==i] = x[i]
    }
    if (plot.weights == TRUE) {
      plot(mat[,1], type = "l", xaxt = "n", xlab = "Category", ylab = "Weight")
      axis(1, at = 1:length(mat[,1]))
      if (min(mat)<0) {abline(h=0, lty = "dotted")}
    }

    return(mat)
  }

  else if (weight.type == "custom") {
  # Custom weights
  wt = custom.weights
  mat = (abs(outer(seq(0, (n-1), 1), seq(0, (n-1), 1), `-`)))+1
  for (i in 1:n) {
    mat[mat==i] = wt[i]
  }
  if (plot.weights == TRUE) {
    plot(mat[,1], type = "l", xaxt = "n", xlab = "Category", ylab = "Weight")
    axis(1, at = 1:length(mat[,1]))
    if (min(mat)<0) {abline(h=0, lty = "dotted")}
  }
  return(mat)
  }

}
